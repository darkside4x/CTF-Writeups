# LITCTF 2025 — Crypto: Encryption Two Ways

**Category:** Crypto  
**Author:** hihitherethere  
**If first solved:** 
---

## Challenge Description

Best of both worlds, right? Symmetric + asymmetric encryption. What could go wrong?  

Connect at: `nc litctf.org 31777`

---

## Challenge Walkthrough

When we connect to the challenge service, it prints two large numbers from a so-called "XOR cipher" and then some RSA parameters.

Xor cipher:  
A = 153810541278167173469024296396091765418772223087411396348016851701336784087929546016644900342755771674582117762320223604161886186686343344820070393714016278203433748619190237718083268095774357774077768404882128501003304161037040011529128576268373953640041629771460667450278454329672954843166135400521539752847  
B = 155418109978442566522654493580108060314381599443630923485179189374046902678475484465104794450622919563115993009239383383920746185887641358531573742191940254757629407437993538772186819946990977840593411322335214344923745538578105075178121890338373849216371821640449091098498148745071720166077382715010260518579  

RSA:  
e = 65537  
N = 23904943620213965852879305765958122029472379514486215217745460410986929380037000485990235357720916086219920373335146701801193229337138102368048690586571814107409432284290130445944413518457328811110241780932933122004103158237214632426075228198533620722038899006535374417454850335891596954597869208671593812273868480254683128317448713744960003730522732985936927906413986266886575512631112996979379037398582764566035809271748724502825145801597623559436567375116460070748823599502911094501320088656223157377836562475012080917089223217977324290389582611873227229138535070261159894003378940294656436538205351365591343634493  
c = 18378071218750098695055476179777746305541687738178295850485703782859973583007469485291643940193108035849544767972971725447449836857399862812912906381869856285569431594505318816429779127013199534278895674885820771786889869741026293124416639755787409727104114593183947628219735252942322453885438224122159907765619028744760547418086162074279133244708604116619924122973055479861790729871242577159893770365765899078078064475918917158972178361804875812109217296455302176371402578769913907568229725338936158202726477994514301415303054219110661807948058776896757522957718866650004814744553651087968049793722866602732940272549  

---

## Analysis

The scheme is straightforward but flawed:

- The flag is XORed with two different pads:  
  A = flag ^ p  
  B = flag ^ q  

- One of the pads (`p` or `q`) is encrypted with RSA and given as `c`.  

If we can decrypt `c` using RSA, we recover the pad. Then we can XOR it back with `A` or `B` to recover the flag.

---

## Exploit Strategy

1. Factor `N`. Since this is a CTF, `N` is deliberately weak and factorable.  
2. Compute `φ(N) = (p-1)(q-1)` and then `d = e^-1 mod φ(N)`.  
3. Decrypt `c` → gives us the pad (`m`).  
4. XOR `m` with both `A` and `B`. One of them yields a readable ASCII string starting with `LITCTF{`.  

---

## Exploit Script (solve.py)
```python
from sympy import factorint
A = 153810541278167173469024296396091765418772223087411396348016851701336784087929546016644900342755771674582117762320223604161886186686343344820070393714016278203433748619190237718083268095774357774077768404882128501003304161037040011529128576268373953640041629771460667450278454329672954843166135400521539752847
B = 155418109978442566522654493580108060314381599443630923485179189374046902678475484465104794450622919563115993009239383383920746185887641358531573742191940254757629407437993538772186819946990977840593411322335214344923745538578105075178121890338373849216371821640449091098498148745071720166077382715010260518579
e = 65537
N = 23904943620213965852879305765958122029472379514486215217745460410986929380037000485990235357720916086219920373335146701801193229337138102368048690586571814107409432284290130445944413518457328811110241780932933122004103158237214632426075228198533620722038899006535374417454850335891596954597869208671593812273868480254683128317448713744960003730522732985936927906413986266886575512631112996979379037398582764566035809271748724502825145801597623559436567375116460070748823599502911094501320088656223157377836562475012080917089223217977324290389582611873227229138535070261159894003378940294656436538205351365591343634493
c = 18378071218750098695055476179777746305541687738178295850485703782859973583007469485291643940193108035849544767972971725447449836857399862812912906381869856285569431594505318816429779127013199534278895674885820771786889869741026293124416639755787409727104114593183947628219735252942322453885438224122159907765619028744760547418086162074279133244708604116619924122973055479861790729871242577159893770365765899078078064475918917158972178361804875812109217296455302176371402578769913907568229725338936158202726477994514301415303054219110661807948058776896757522957718866650004814744553651087968049793722866602732940272549

def i2b(n: int) -> bytes:
    return n.to_bytes((n.bit_length() + 7) // 8, "big")
def main():
    print("[*] Factoring N...")
    fac = factorint(N)
    p, q = list(fac.keys())
    phi = (p - 1) * (q - 1)
    d = pow(e, -1, phi)
    m = pow(c, d, N)
    print("[+] Decrypted pad m:", m)
    flagA = i2b(A ^ m)
    flagB = i2b(B ^ m)

    for candidate in [flagA, flagB]:
        try:
            text = candidate.decode()
        except:
            text = str(candidate)
        if "LITCTF{" in text:
            print("[FLAG] ", text)
            break
if __name__ == "__main__":
    main()

```
---

## Running the Script

python3 solve.py  

The script prints both XOR attempts and automatically extracts the valid one containing `LITCTF{...}`.

---

## Conclusion

This challenge demonstrates that stacking weak encryption schemes doesn’t create security. By factoring a deliberately weak RSA modulus, we recovered the XOR pad. With that, the XOR cipher collapses instantly and the flag is revealed.

**Final Flag:** LITCTF{th3_s1mpl3_c0mb1n4t10n_but_br0k3n}
